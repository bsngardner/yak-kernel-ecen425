; Generated by c86 (BYU-NASM) 5.1 (beta) from main.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
L_main_3:
	DB	"Finished initializing kernel",0
L_main_2:
	DB	"Creating queues and semaphores",0
L_main_1:
	DB	"Initializing kernel",0
	ALIGN	2
main:
	; >>>>> Line:	41
	; >>>>> void main(void){ 
	jmp	L_main_4
L_main_5:
	; >>>>> Line:	42
	; >>>>> printString("Initializing kernel"); 
	mov	ax, L_main_1
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	43
	; >>>>> printNewLine(); 
	call	printNewLine
	; >>>>> Line:	44
	; >>>>> YKInitialize(); 
	call	YKInitialize
	; >>>>> Line:	46
	; >>>>> printString("Creating queues and semaphores"); 
	mov	ax, L_main_2
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	47
	; >>>>> printNewLine(); 
	call	printNewLine
	; >>>>> Line:	49
	; >>>>> cmd_sem = YKSemCreate(1); 
	mov	ax, 1
	push	ax
	call	YKSemCreate
	add	sp, 2
	mov	word [cmd_sem], ax
	; >>>>> Line:	50
	; >>>>> cmd_q = YKQCreate(cmd_buffer, 64); 
	mov	ax, 64
	push	ax
	mov	ax, cmd_buffer
	push	ax
	call	YKQCreate
	add	sp, 4
	mov	word [cmd_q], ax
	; >>>>> Line:	51
	; >>>>> new_q = YKQCreate(new_buffer,64); 
	mov	ax, 64
	push	ax
	mov	ax, new_buffer
	push	ax
	call	YKQCreate
	add	sp, 4
	mov	word [new_q], ax
	; >>>>> Line:	52
	; >>>>> YKNewTask(stats_task, (void*) &stats_task_stack[256],0); 
	xor	al, al
	push	ax
	mov	ax, (stats_task_stack+512)
	push	ax
	mov	ax, stats_task
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	54
	; >>>>> printString("Finished initializing kernel"); 
	mov	ax, L_main_3
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	55
	; >>>>> printNewLine(); 
	call	printNewLine
	; >>>>> Line:	56
	; >>>>> SeedSimptris(73706); 
	mov	ax, 8170
	mov	dx, 1
	push	dx
	push	ax
	call	SeedSimptris
	add	sp, 4
	; >>>>> Line:	57
	; >>>>> YKRun(); 
	call	YKRun
	mov	sp, bp
	pop	bp
	ret
L_main_4:
	push	bp
	mov	bp, sp
	jmp	L_main_5
L_main_7:
	DB	"cmd task begun",0
	ALIGN	2
cmd_task:
	; >>>>> Line:	60
	; >>>>> void cmd_task(void){ 
	jmp	L_main_8
L_main_9:
	; >>>>> Line:	66
	; >>>>> printString("cmd task begun"); 
	mov	ax, L_main_7
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	67
	; >>>>> printNewLine(); 
	call	printNewLine
	; >>>>> Line:	69
	; >>>>> while(1){ 
	jmp	L_main_11
L_main_10:
	; >>>>> Line:	70
	; >>>>> cmd = (int) YKQPend(cmd_q); 
	push	word [cmd_q]
	call	YKQPend
	add	sp, 2
	mov	word [bp-2], ax
	; >>>>> Line:	71
	; >>>>> id = (cmd >> 2); 
	mov	ax, word [bp-2]
	sar	ax, 1
	sar	ax, 1
	mov	word [bp-8], ax
	; >>>>> Line:	72
	; >>>>> dir = (cmd & 1); 
	mov	ax, word [bp-2]
	and	ax, 1
	mov	word [bp-4], ax
	; >>>>> Line:	73
	; >>>>> mode = ((cmd >> 1) & 1); 
	mov	ax, word [bp-2]
	sar	ax, 1
	and	ax, 1
	mov	word [bp-6], ax
	; >>>>> Line:	75
	; >>>>> YKSemPend(cmd_sem); 
	push	word [cmd_sem]
	call	YKSemPend
	add	sp, 2
	; >>>>> Line:	76
	; >>>>> if(mode){ 
	mov	ax, word [bp-6]
	test	ax, ax
	je	L_main_13
	; >>>>> Line:	77
	; >>>>> SlidePiece(id,dir); 
	push	word [bp-4]
	push	word [bp-8]
	call	SlidePiece
	add	sp, 4
	jmp	L_main_14
L_main_13:
	; >>>>> Line:	79
	; >>>>> RotatePiece(id,dir); 
	push	word [bp-4]
	push	word [bp-8]
	call	RotatePiece
	add	sp, 4
L_main_14:
L_main_11:
	jmp	L_main_10
L_main_12:
	mov	sp, bp
	pop	bp
	ret
L_main_8:
	push	bp
	mov	bp, sp
	sub	sp, 8
	jmp	L_main_9
L_main_16:
	DB	"placement task begun",0
	ALIGN	2
placement_task:
	; >>>>> Line:	90
	; >>>>> void placement_task(void){ 
	jmp	L_main_17
L_main_18:
	; >>>>> Line:	95
	; >>>>> bin[0].ht = 0; 
	mov	word [(2+bin)], 0
	; >>>>> Line:	96
	; >>>>> bin[1].ht = 1; 
	mov	word [(8+bin)], 1
	; >>>>> Line:	97
	; >>>>> bin[0].flat = 0x01; 
	mov	word [bin], 1
	; >>>>> Line:	98
	; >>>>> bin[1].flat = 0x02; 
	mov	word [(6+bin)], 2
	; >>>>> Line:	99
	; >>>>> bin[0].x = 0; 
	mov	word [(4+bin)], 0
	; >>>>> Line:	100
	; >>>>> bin[1 
	mov	word [(10+bin)], 5
	; >>>>> Line:	102
	; >>>>> printString("placement task begun"); 
	mov	ax, L_main_16
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	103
	; >>>>> printNewLine(); 
	call	printNewLine
	; >>>>> Line:	105
	; >>>>> while(1){ 
	jmp	L_main_20
L_main_19:
	; >>>>> Line:	106
	; >>>>> new = (struct piece*)YKQPend(new_q); 
	push	word [new_q]
	call	YKQPend
	add	sp, 2
	mov	word [bp-2], ax
	; >>>>> Line:	107
	; >>>>> if(new->x == 0){ 
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	test	ax, ax
	jne	L_main_22
	; >>>>> Line:	108
	; >>>>> cmd = ((new->id << 2) | (1 << 1) | 1); 
	mov	si, word [bp-2]
	mov	ax, word [si]
	shl	ax, 1
	shl	ax, 1
	or	ax, 2
	or	ax, 1
	mov	word [bp-6], ax
	; >>>>> Line:	109
	; >>>>> YKQPost(cmd_q,(void*)cmd); 
	push	word [bp-6]
	push	word [cmd_q]
	call	YKQPost
	add	sp, 4
	; >>>>> Line:	110
	; >>>>> new->x = 1; 
	mov	si, word [bp-2]
	add	si, 4
	mov	word [si], 1
	jmp	L_main_23
L_main_22:
	; >>>>> Line:	111
	; >>>>> }else if(new->x == 5){ 
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 5
	jne	L_main_24
	; >>>>> Line:	112
	; >>>>> cmd = ((new->id << 2) | (1 << 1) | 0); 
	mov	si, word [bp-2]
	mov	ax, word [si]
	shl	ax, 1
	shl	ax, 1
	or	ax, 2
	mov	word [bp-6], ax
	; >>>>> Line:	113
	; >>>>> YKQPost(cmd_q,(void*)cmd); 
	push	word [bp-6]
	push	word [cmd_q]
	call	YKQPost
	add	sp, 4
	; >>>>> Line:	114
	; >>>>> new->x = 4; 
	mov	si, word [bp-2]
	add	si, 4
	mov	word [si], 4
L_main_24:
L_main_23:
	; >>>>> Line:	116
	; >>>>> if(new->type == 1){ 
	mov	si, word [bp-2]
	add	si, 2
	cmp	word [si], 1
	jne	L_main_25
	; >>>>> Line:	117
	; >>>>> switch(bin[0].flat + bin[1].flat){ 
	mov	ax, word [(6+bin)]
	add	ax, word [bin]
	dec	ax
	je	L_main_27
	dec	ax
	je	L_main_28
	dec	ax
	je	L_main_29
	jmp	L_main_26
L_main_27:
	; >>>>> Line:	119
	; >>>>> new->trans = bin[0].x + 1 - new->x; 
	mov	ax, word [(4+bin)]
	mov	si, word [bp-2]
	add	si, 4
	sub	ax, word [si]
	inc	ax
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], ax
	; >>>>> Line:	120
	; >>>>> break; 
	jmp	L_main_26
L_main_28:
	; >>>>> Line:	122
	; >>>>> ; 
	mov	ax, word [(10+bin)]
	mov	si, word [bp-2]
	add	si, 4
	sub	ax, word [si]
	dec	ax
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], ax
	; >>>>> Line:	123
	; >>>>> break; 
	jmp	L_main_26
L_main_29:
	; >>>>> Line:	125
	; >>>>> if(bin[0].ht == bin[1].ht){ 
	mov	ax, word [(8+bin)]
	cmp	ax, word [(2+bin)]
	jne	L_main_30
	; >>>>> Line:	126
	; >>>>> if(new->x <= 3){ 
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 3
	jg	L_main_31
	; >>>>> Line:	127
	; >>>>> new->trans = bin[0].x + 1 - new->x; 
	mov	ax, word [(4+bin)]
	mov	si, word [bp-2]
	add	si, 4
	sub	ax, word [si]
	inc	ax
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], ax
	jmp	L_main_32
L_main_31:
	; >>>>> Line:	129
	; >>>>> new->trans = bin[1].x - 1 - new->x; 
	mov	ax, word [(10+bin)]
	mov	si, word [bp-2]
	add	si, 4
	sub	ax, word [si]
	dec	ax
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], ax
L_main_32:
	jmp	L_main_33
L_main_30:
	; >>>>> Line:	131
	; >>>>> }else if(bin[0].ht<bin[1].ht){ 
	mov	ax, word [(8+bin)]
	cmp	ax, word [(2+bin)]
	jle	L_main_34
	; >>>>> Line:	132
	; >>>>> new->trans = bin[0].x + 1 - new->x; 
	mov	ax, word [(4+bin)]
	mov	si, word [bp-2]
	add	si, 4
	sub	ax, word [si]
	inc	ax
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], ax
	jmp	L_main_35
L_main_34:
	; >>>>> Line:	134
	; >>>>> new->trans = bin[1].x - 1 - new->x; 
	mov	ax, word [(10+bin)]
	mov	si, word [bp-2]
	add	si, 4
	sub	ax, word [si]
	dec	ax
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], ax
L_main_35:
L_main_33:
L_main_26:
	; >>>>> Line:	136
	; >>>>> break; 
	jmp	L_main_36
L_main_25:
	; >>>>> Line:	140
	; >>>>> switch(bin[0].flat + bin[1].flat){ 
	mov	ax, word [(6+bin)]
	add	ax, word [bin]
	dec	ax
	je	L_main_38
	dec	ax
	je	L_main_39
	dec	ax
	je	L_main_40
	jmp	L_main_37
L_main_38:
	; >>>>> Line:	143
	; >>>>> new->trans = bin[1].x -2 - new->x; 
	mov	ax, word [(10+bin)]
	mov	si, word [bp-2]
	add	si, 4
	sub	ax, word [si]
	add	ax, -2
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], ax
	; >>>>> Line:	144
	; >>>>> new->rot = 3-new->rot; 
	mov	ax, 3
	mov	si, word [bp-2]
	add	si, 6
	sub	ax, word [si]
	mov	si, word [bp-2]
	add	si, 6
	mov	word [si], ax
	; >>>>> Line:	145
	; >>>>> rot; 
	mov	word [(6+bin)], 2
	; >>>>> Line:	146
	; >>>>> break; 
	jmp	L_main_37
L_main_39:
	; >>>>> Line:	149
	; >>>>> new->trans = bin[0].x + 2 - new->x; 
	mov	ax, word [(4+bin)]
	mov	si, word [bp-2]
	add	si, 4
	sub	ax, word [si]
	add	ax, 2
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], ax
	; >>>>> Line:	150
	; >>>>> new->rot = 2-new->rot; 
	mov	ax, 2
	mov	si, word [bp-2]
	add	si, 6
	sub	ax, word [si]
	mov	si, word [bp-2]
	add	si, 6
	mov	word [si], ax
	; >>>>> Line:	151
	; >>>>> bin[0].flat = 0x01; 
	mov	word [bin], 1
	; >>>>> Line:	152
	; >>>>> break; 
	jmp	L_main_37
L_main_40:
	; >>>>> Line:	154
	; >>>>> if(bin[0].ht == bin[1].ht){ 
	mov	ax, word [(8+bin)]
	cmp	ax, word [(2+bin)]
	jne	L_main_41
	; >>>>> Line:	155
	; >>>>> if(new->x <= 3){ 
	mov	si, word [bp-2]
	add	si, 4
	cmp	word [si], 3
	jg	L_main_42
	; >>>>> Line:	156
	; >>>>> new->trans = bin[0].x-new->x; 
	mov	ax, word [(4+bin)]
	mov	si, word [bp-2]
	add	si, 4
	sub	ax, word [si]
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], ax
	; >>>>> Line:	157
	; >>>>> new->rot = 0 - new->rot; 
	mov	si, word [bp-2]
	add	si, 6
	mov	ax, word [si]
	neg	ax
	mov	si, word [bp-2]
	add	si, 6
	mov	word [si], ax
	; >>>>> Line:	158
	; >>>>> bin[0].flat = 0; 
	mov	word [bin], 0
	jmp	L_main_43
L_main_42:
	; >>>>> Line:	160
	; >>>>> new->trans = bin[1].x - new->x; 
	mov	ax, word [(10+bin)]
	mov	si, word [bp-2]
	add	si, 4
	sub	ax, word [si]
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], ax
	; >>>>> Line:	161
	; >>>>> new->rot = 1 - new->rot; 
	mov	ax, 1
	mov	si, word [bp-2]
	add	si, 6
	sub	ax, word [si]
	mov	si, word [bp-2]
	add	si, 6
	mov	word [si], ax
	; >>>>> Line:	162
	; >>>>> bin[1].flat = 0; 
	mov	word [(6+bin)], 0
L_main_43:
	jmp	L_main_44
L_main_41:
	; >>>>> Line:	164
	; >>>>> }else if(bin[0].ht<bin[1].ht){ 
	mov	ax, word [(8+bin)]
	cmp	ax, word [(2+bin)]
	jle	L_main_45
	; >>>>> Line:	166
	; >>>>> new->trans = bin[0].x-new->x; 
	mov	ax, word [(4+bin)]
	mov	si, word [bp-2]
	add	si, 4
	sub	ax, word [si]
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], ax
	; >>>>> Line:	167
	; >>>>> new->rot = 0 - new->rot; 
	mov	si, word [bp-2]
	add	si, 6
	mov	ax, word [si]
	neg	ax
	mov	si, word [bp-2]
	add	si, 6
	mov	word [si], ax
	; >>>>> Line:	168
	; >>>>> w->tr 
	mov	word [bin], 0
	jmp	L_main_46
L_main_45:
	; >>>>> Line:	171
	; >>>>> new->trans = bin[1].x - new->x; 
	mov	ax, word [(10+bin)]
	mov	si, word [bp-2]
	add	si, 4
	sub	ax, word [si]
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], ax
	; >>>>> Line:	172
	; >>>>> new->rot = 1 - new->rot; 
	mov	ax, 1
	mov	si, word [bp-2]
	add	si, 6
	sub	ax, word [si]
	mov	si, word [bp-2]
	add	si, 6
	mov	word [si], ax
	; >>>>> Line:	173
	; >>>>> bin[1].flat = 0; 
	mov	word [(6+bin)], 0
L_main_46:
L_main_44:
L_main_37:
L_main_36:
	; >>>>> Line:	175
	; >>>>> break; 
	; >>>>> Line:	179
	; >>>>> dir = new->rot < 0; 
	mov	si, word [bp-2]
	add	si, 6
	cmp	word [si], 0
	jl	L_main_47
	xor	ax, ax
	jmp	L_main_48
L_main_47:
	mov	ax, 1
L_main_48:
	mov	word [bp-4], ax
	; >>>>> Line:	180
	; >>>>> cmd = ((new->id << 2) | (0 << 1) | dir); 
	mov	si, word [bp-2]
	mov	ax, word [si]
	shl	ax, 1
	shl	ax, 1
	or	ax, word [bp-4]
	mov	word [bp-6], ax
	; >>>>> Line:	181
	; >>>>> while(new->rot){ 
	jmp	L_main_50
L_main_49:
	; >>>>> Line:	182
	; >>>>> YKQPost(cmd_q,(void*)cmd); 
	push	word [bp-6]
	push	word [cmd_q]
	call	YKQPost
	add	sp, 4
	; >>>>> Line:	183
	; >>>>> if(dir) 
	mov	ax, word [bp-4]
	test	ax, ax
	je	L_main_52
	; >>>>> Line:	184
	; >>>>> new->rot++; 
	mov	si, word [bp-2]
	add	si, 6
	inc	word [si]
	jmp	L_main_53
L_main_52:
	; >>>>> Line:	186
	; >>>>> new->rot--; 
	mov	si, word [bp-2]
	add	si, 6
	dec	word [si]
L_main_53:
L_main_50:
	mov	si, word [bp-2]
	add	si, 6
	mov	ax, word [si]
	test	ax, ax
	jne	L_main_49
L_main_51:
	; >>>>> Line:	189
	; >>>>> dir = new->trans > 0; 
	mov	si, word [bp-2]
	add	si, 8
	cmp	word [si], 0
	jg	L_main_54
	xor	ax, ax
	jmp	L_main_55
L_main_54:
	mov	ax, 1
L_main_55:
	mov	word [bp-4], ax
	; >>>>> Line:	190
	; >>>>> cmd = ((new->id << 2) | (1 << 1) | dir); 
	mov	si, word [bp-2]
	mov	ax, word [si]
	shl	ax, 1
	shl	ax, 1
	or	ax, 2
	or	ax, word [bp-4]
	mov	word [bp-6], ax
	; >>>>> Line:	191
	; >>>>> while(new->trans){ 
	jmp	L_main_57
L_main_56:
	; >>>>> Line:	192
	; >>>>> YKQPost(cmd_q,(void*)cmd); 
	push	word [bp-6]
	push	word [cmd_q]
	call	YKQPost
	add	sp, 4
	; >>>>> Line:	193
	; >>>>> if(dir) 
	mov	ax, word [bp-4]
	test	ax, ax
	je	L_main_59
	; >>>>> Line:	194
	; >>>>> new->trans--; 
	mov	si, word [bp-2]
	add	si, 8
	dec	word [si]
	jmp	L_main_60
L_main_59:
	; >>>>> Line:	196
	; >>>>> new->tr 
	mov	si, word [bp-2]
	add	si, 8
	inc	word [si]
L_main_60:
L_main_57:
	mov	si, word [bp-2]
	add	si, 8
	mov	ax, word [si]
	test	ax, ax
	jne	L_main_56
L_main_58:
L_main_20:
	jmp	L_main_19
L_main_21:
	mov	sp, bp
	pop	bp
	ret
L_main_17:
	push	bp
	mov	bp, sp
	sub	sp, 6
	jmp	L_main_18
L_main_66:
	DB	"%>",0xD,0xA,0
L_main_65:
	DB	", CPU: ",0
L_main_64:
	DB	"<CS: ",0
L_main_63:
	DB	"Determining CPU capacity",0xD,0xA,0
L_main_62:
	DB	"Welcome to the YAK kernel",0xD,0xA,0
	ALIGN	2
stats_task:
	; >>>>> Line:	201
	; >>>>> void stats_task(void){ 
	jmp	L_main_67
L_main_68:
	; >>>>> Line:	205
	; >>>>> YKDelayTask(1); 
	mov	ax, 1
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	206
	; >>>>> printString("Welcome to the YAK kernel\r\n"); 
	mov	ax, L_main_62
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	207
	; >>>>> printString("Determining CPU capacity\r\n"); 
	mov	ax, L_main_63
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	208
	; >>>>> YKDelayTask(1); 
	mov	ax, 1
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	209
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	210
	; >>>>> YKDelayTask(5); 
	mov	ax, 5
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	211
	; >>>>> max = YKIdleCount / 25; 
	mov	ax, word [YKIdleCount]
	cwd
	mov	cx, 25
	idiv	cx
	mov	word [bp-2], ax
	; >>>>> Line:	212
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	214
	; >>>>> YKNewTask(placement_task, (void *) &placement_task_stack[256], 2); 
	mov	al, 2
	push	ax
	mov	ax, (placement_task_stack+512)
	push	ax
	mov	ax, placement_task
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	215
	; >>>>> YKNewTask(cmd_task, (void *) &cmd_task_stack[256], 1); 
	mov	al, 1
	push	ax
	mov	ax, (cmd_task_stack+512)
	push	ax
	mov	ax, cmd_task
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	216
	; >>>>> StartSimptris(); 
	call	StartSimptris
	; >>>>> Line:	218
	; >>>>> while (1){ 
	jmp	L_main_70
L_main_69:
	; >>>>> Line:	219
	; >>>>> YKDelayTask(20); 
	mov	ax, 20
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	221
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	222
	; >>>>>  
	mov	ax, word [YKCtxSwCount]
	mov	word [bp-4], ax
	; >>>>> Line:	223
	; >>>>> idleCount = YKIdleCount; 
	mov	ax, word [YKIdleCount]
	mov	word [bp-6], ax
	; >>>>> Line:	224
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	226
	; >>>>> printString("<CS: "); 
	mov	ax, L_main_64
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	227
	; >>>>> printInt((int)switchCount); 
	push	word [bp-4]
	call	printInt
	add	sp, 2
	; >>>>> Line:	228
	; >>>>> printString(", CPU: "); 
	mov	ax, L_main_65
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	229
	; >>>>> tmp = (int) (idleCount/max); 
	mov	ax, word [bp-6]
	xor	dx, dx
	div	word [bp-2]
	mov	word [bp-8], ax
	; >>>>> Line:	230
	; >>>>> printInt(100-tmp); 
	mov	ax, 100
	sub	ax, word [bp-8]
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	231
	; >>>>> printString("%>\r\n"); 
	mov	ax, L_main_66
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	233
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	234
	; >>>>> YKCtxSwCount = 0; 
	mov	word [YKCtxSwCount], 0
	; >>>>> Line:	235
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	236
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_main_70:
	jmp	L_main_69
L_main_71:
	mov	sp, bp
	pop	bp
	ret
L_main_67:
	push	bp
	mov	bp, sp
	sub	sp, 8
	jmp	L_main_68
	ALIGN	2
new_q:
	TIMES	2 db 0
cmd_sem:
	TIMES	2 db 0
bin:
	TIMES	12 db 0
stats_task_stack:
	TIMES	512 db 0
cmd_task_stack:
	TIMES	512 db 0
placement_task_stack:
	TIMES	512 db 0
cmd_buffer:
	TIMES	128 db 0
cmd_q:
	TIMES	2 db 0
new_buffer:
	TIMES	128 db 0
pieces:
	TIMES	192 db 0
