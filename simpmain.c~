/*
 * Main c code for simptris game
 *
 *
 * Broderick Gardner and Thomas Tryon
 */

#include "clib.h"
#include "yakk.h"
#include "simptris.h"

#define STACK_SIZE 512
#define 256

int stats_task_stack[STACK_SIZE];
int comm_task_stack[STACK_SIZE];
int placement_task_stack[STACK_SIZE];

YKSEM* cmd_sem;

void* cmd_buffer[QSIZE];
YKQ* cmd_q;

void* new_buffer[QSIZE];
YKQ* new_q;

void command_task(void);
void comm_task(void);
void placement_task(void);
void stats_task(void);

struct command{
  int id;
  int mode;
  int dir;
};

struct bin{
  int flat;
  int ht;
  int x;
};

struct piece {
  int id;
  int type;
  int x;
  int rot;
  int trans;
  struct piece* next;
};

void main(void){
  YKInitialize();

  cmd_sem = YKSemCreate(1);
  move_command_q = YKQCreate(command_buffer, QSIZE);
  YKNewTask(stats_task, (void*) &stats_task_stack,0);
  
  YKRun();
}

void cmd_task(void){
  struct command* cmd;
  while(1){
    cmd = (struct command*) YKQPend(cmd_q);
    YKSemPend(cmd_sem);
    if(cmd->mode){
      SlidePiece(cmd->id,cmd->dir);
    }else{
      RotatePiece(cmd->id,cmd->dir);
    }
  }
}

void comm_task(void){
  
}


struct bin bin[2];
#define MAX_PIECES 16
struct piece pieces[MAX_PIECES];
struct piece root;
struct piece can;

void fill_can(){
  int i;
  
  can.next = pieces;
  for(i=0;i<MAX_PIECES-1;i++){
    pieces[i].next = pieces + i + 1;
  }
}

void placement_task(void){
  struct piece* new;
 while(1){
   new = (struct piece*)YKQPend(new_q);
   if(new->type == FLAT){
     switch(bin[0].flat + bin[1].flat){
     case 1:
       new->trans = bin[0].x + 1 - new->x;
       break;
     case 2:
       new->trans = bin[1].x + 1 - new->x;
       break;
     case 3:
       if(bin[0].ht<bin[1].ht){
	 new->trans = bin[0].x + 1 - new->x;	 
       }else{
	 new->trans = bin[1].x + 1 - new->x;	 
       }
       break;
     }
   }else{ //Corner
     switch(bin[0].flat + bin[1].flat){
     case 1:
       //bin 1
       new->trans = bin[1].x - new->x;
       new->rot = 3-new->rot;
       break;
     case 2:
       //bin 0
       new->trans = bin[0].x + 2 - new->x;
       new->rot = 2-new->rot;
       break;
     case 3:
       if(bin[0].ht<bin[1].ht){
	 //bin 0
	 new->trans = bin[0].x-new->x;
	 new->rot = 0 - new->rot;
       }else{
	 //bin 1
	 new->trans = bin[1].x + 2 - new->x;
	 new->rot = 1 - new->x;
       }
       break;
     }
   }
   
 }
  
}

void stats_task(void){
  unsigned max, switchCount, idleCount;
  int tmp;

  YKDelayTask(1);
  printString("Welcome to the YAK kernel\r\n");
  printString("Determining CPU capacity\r\n");
  YKDelayTask(1);
  YKIdleCount = 0;
  YKDelayTask(5);
  max = YKIdleCount / 25;
  YKIdleCount = 0;
  
  YKNewTask(CharTask, (void *) &CharTaskStk[TASK_STACK_SIZE], 2);
  YKNewTask(AllNumsTask, (void *) &AllNumsTaskStk[TASK_STACK_SIZE], 1);
    YKNewTask(AllCharsTask, (void *) &AllCharsTaskStk[TASK_STACK_SIZE], 3);
    
    while (1){
      YKDelayTask(20);
      
      YKEnterMutex();
      switchCount = YKCtxSwCount;
      idleCount = YKIdleCount;
      YKExitMutex();
      
      printString("<CS: ");
      printInt((int)switchCount);
      printString(", CPU: ");
      tmp = (int) (idleCount/max);
      printInt(100-tmp);
      printString("%>\r\n");
      
      YKEnterMutex();
      YKCtxSwCount = 0;
      YKIdleCount = 0;
      YKExitMutex();
    }
}
